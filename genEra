#!/bin/bash

### genEra v1.0 (C) Max Planck Society for the Advancement of Science
###
### Code developed by Josu√© Barrera-Redondo <josue.barrera@tuebingen.mpg.de>
###
### This program is free software: you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation, either version 3 of the License, or
### (at your option) any later version.
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.

QUERY_FASTA=''
NCBITAX=''
NR_DB=''
THREADS='20'
THRESHOLD='30'
DIAMONDOUT=''
TAXDUMP=''
RAWTAX=''
CUSTOMTAX=''
CUSTOMDATA=''
CUSTOMGENOMES=''
EVALUE='1e-5'
DIAMONDOPTS=''
MINHITS='10'
PRINTOLDEST='false'
DIVERGENCE=''
TMP_PATH=''
SENSITIVITY='ultra-sensitive'

print_usage() {
  printf "\ngenEra v1.0 (C) Max Planck Society for the Advancement of Science\n\n  BASIC USAGE\n\tgenEra -q [query_sequences.fasta] -t [query_taxid] -b [path/to/nr] -d [path/to/taxdump]\n\n  BEST USAGE\n\tgenEra -q [query_sequences.fasta] -t [query_taxid] -b [path/to/nr] -d [path/to/taxdump] \ \n\t-a [protein_list.tsv] -f [nucleotide_list.tsv] -s [evolutionary_distances.tsv] -i [true] -n [many threads]\n\n  DESCRIPTION\n\tgenEra is an easy-to-use, low-dependency command-line tool that\n\testimates the age of the earliest common ancestor of protein\n\tcoding genes though genomic phylostratigraphy.\n\n  MANDATORY ARGUMENTS\n\t-q\tQuery protein sequences in FASTA format\n\t-t\tNCBI Taxonomy ID of query species (search for the taxid of\n\t\tyour query species at https://www.ncbi.nlm.nih.gov/taxonomy)\n\n  MANDATORY ONE OF THE FOLLOWING ARGUMENTS\n\t-b\tPath to a locally installed nr database for DIAMOND\n\t-p\tPre-generated DIAMOND/MMseqs2 table (skip step 1), with the\n\t\tquery genes in the first column, the bitscore in the second\n\t\tto last column and the target taxid in the last column\n\t\t(IMPORTANT: the query sequences must be searched\n\t\tagainst themselves for genEra to work properly)\n\n  ALSO MANDATORY ONE OF THESE THREE ARGUMENTS\n\t-d\tLocation of the uncompressed taxonomy dump from the NCBI\n\t\t(ftp://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz)\n\t-r\tRaw \"ncbi_lineages\" file generated by ncbitax2lin\n\t\t(saves time on step 2)\n\t-c\tCustom \"ncbi_lineages\" file that is already tailored for the\n\t\tquery species (skip step 2). The table should be arranged so\n\t\tthat the taxid is in the first column and all the phylostrata\n\t\tof interest are organized from the species level all the way\n\t\tback to \"cellular organisms\"\n\n  IMPORTANT OPTIONAL ARGUMENTS\n\t-n\tNumber of threads to run genEra (genEra can run with a single\n\t\tthread, but it is HIGHLY suggested to use as many threads as\n\t\tpossible) (default: 20 threads)\n\t-s\tTable with pairwise evolutionary distances (substitutions/site)\n\t\tbetween several species in the database and the query species\n\t\t(necessary to calculate homology detection failure probabilities\n\t\twith abSENSE). NOTE: the query species SHOULD be included in\n\t\tthis table. The table should be tab-delimited and have the\n\t\tfollowing format:\n\t\t   query_sp_taxid\t0\n\t\t   species_1_taxid\tdistance_1\n\t\t   species_2_taxid\tdistance_2\n\t-a\tTable with additional proteins to be included in the analysis\n\t\t(e.g., proteins from species that are absent from the nr).\n\t\tThe table should be tab-delimited and have the following format:\n\t\t   /path/to/species_1.fasta\ttaxid_1\n\t\t   /path/to/species_2.fasta\ttaxid_2\n\t\t   /path/to/species_3.fasta\ttaxid_3\n\t-f\tTable with additional nucleotide sequences to be search against\n\t\tyour query proteins. Particularly useful with genome assemblies\n\t\tfor improved orphan gene classification. The table should be\n\t\ttab-delimited and have the following format:\n\t\t   /path/to/genome_1.fasta\ttaxid_1\n\t\t   /path/to/genome_2.fasta\ttaxid_2\n\t\t   /path/to/genome_3.fasta\ttaxid_3\n\t-i\tWhen true, prints an additional output file with the best\n\t\tsequence hit responsible for the oldest phylostrata assignment\n\t\tfor each of the query genes (default: false)\n\n  FINE-TUNNING ARGUMENTS (DEFAULT IS USUALLY FINE)\n\t-l\tTaxonomic representativeness threshold below which a gene will\n\t\tbe flagged as putative genome contamination or the product of\n\t\ta horizontal gene transfer (HGT) event (default: 30)\n\t-e\tE-value threshold for DIAMOND and MMseqs2 (default: 1e-5)\n\t-o\tAdditional options to feed DIAMOND, based on user preferences\n\t\t(e.g., filtering the hits by identity or query coverage)\n\t\tUsers should input the additional commands in quotes, using\n\t\tthe original arguments from DIAMOND (Example: -o \"--id 30\")\n\t-m\tMinimum percentage of matches between your query sequences\n\t\tand another species to consider it useful for the gene age\n\t\tassignment (i.e., filtering species with just a couple of\n\t\tgenes in the nr)(default: 10)\n\t-x\tAlternative path where you would like to store the temporary\n\t\tfiles as well as the DIAMOND/MMseqs2 results (warning: genEra\n\t\twill generate HUGE temporary files) (default: the files will\n\t\tbe stored in a tmp_[RAMDOMNUM]/ directory created by genEra)\n\t-y\tModify the sensitivity parameter in DIAMOND for faster\n\t\tresults in step 1 (default: ultra-sensitive)\n\t-h\tPrint this help message and exit\n\n"
}

while getopts ':q:t:b:n:l:p:d:r:c:a:f:e:o:m:i:s:x:y:h' flag; do
  case "${flag}" in
    q) QUERY_FASTA=${OPTARG} ;;
    t) NCBITAX=${OPTARG} ;;
    b) NR_DB=${OPTARG} ;;
    n) THREADS=${OPTARG} ;;
    l) THRESHOLD=${OPTARG} ;;
    p) DIAMONDOUT=${OPTARG} ;;
    d) TAXDUMP=${OPTARG} ;;
    r) RAWTAX=${OPTARG} ;;
    c) CUSTOMTAX=${OPTARG} ;;
    a) CUSTOMDATA=${OPTARG} ;;
    f) CUSTOMGENOMES=${OPTARG} ;;
    e) EVALUE=${OPTARG} ;;
    o) DIAMONDOPTS=${OPTARG} ;;
    m) MINHITS=${OPTARG} ;;
    i) PRINTOLDEST=${OPTARG} ;;
    s) DIVERGENCE=${OPTARG} ;;
    x) TMP_PATH=${OPTARG} ;;
    y) SENSITIVITY=${OPTARG} ;;
    h) print_usage ; exit;;
    *) echo ; echo "  ERROR: One or more invalid arguments"; print_usage ; exit;;
  esac
done

# Check if Erassingnation.sh was added to the PATH
PHYLOSCRIPT=$(which Erassignment)
 if [[ -z ${PHYLOSCRIPT} ]]; then
	echo
	echo "  ERROR: Please make sure that Erassignment is located in your PATH"
	echo
	exit 1
fi

# Check if mcl is correctly installed
MCLEXEC=$(which mcl)
MCXLOADEXEC=$(which mcxload)
MCXDUMPEXEC=$(which mcxdump)
if [[ -z ${MCLEXEC} ]] || [[ -z ${MCXLOADEXEC} ]] || [[ -z ${MCXDUMPEXEC} ]]; then
        echo
        echo "  ERROR: Please make sure that mcl, mcxload and mcxdump are located in your PATH"
        echo
        exit 1
fi

# Check if the mandarory arguments were used
if [ ! "$QUERY_FASTA" ] || [ ! "$NCBITAX" ]; then
	echo
	echo "  ERROR: The user must provide a protein FASTA file (-q) and the NCBI taxonomy ID of the query species (-t)"
	print_usage >&2; exit 1
fi

# Quick check to verify that the input sequences exist
if [[ ! -f $QUERY_FASTA ]]; then
	echo
	echo "  ERROR: The query FASTA file ${QUERY_FASTA} does not exist"
	print_usage >&2; exit 1
fi

# Check whether the user specified the other mandarory arguments
if [ -z "$NR_DB" ] && [ -z "$DIAMONDOUT" ]; then
        echo
        echo "  ERROR: The user must provide either the path to a local nr database (-b) or a pre-generated BLAST/DIAMOND table (-p)"
        print_usage >&2; exit 1
fi

if [ -z "$TAXDUMP" ] && [ -z "$RAWTAX" ] && [ -z "$CUSTOMTAX" ]; then
	echo
	echo "  ERROR: One of the following arguments must be provided (-d, -r or -c)"
	print_usage >&2; exit 1
fi

# If homology detection failure is invoked, make sure that abSENSE is installed and that the input file exists
if [[ -f ${DIVERGENCE} ]]; then

	ABSENSE_SCRIPT=$(which Run_abSENSE.py)
	if [[ -z ${ABSENSE_SCRIPT} ]]; then
		echo
		echo "  ERROR: Run_abSENSE.py was invoked (-s), but the script is not located in your PATH"
		echo "  Please make sure to install it correctly"
		echo
		exit 1
	fi

	if [[ ! -f ${DIVERGENCE} ]]; then
		echo
		echo "  ERROR: genEra could not find the file with the pairwise evolutionary distances:"
		echo "  ${DIVERGENCE}"
		echo "  Exiting"
		exit 1
	fi
fi

echo "genEra v1.0 (C) Max Planck Society for the Advancement of Science"
echo "Starting time of run:"
date

# create a temporary directory if no specific path is given by the user
if [[ -z ${TMP_PATH} ]]; then
	RANDOMSEED=$(echo $RANDOM)
	mkdir tmp_${NCBITAX}_${RANDOMSEED} && cd tmp_${NCBITAX}_${RANDOMSEED}
	TMP_PATH=$(pwd)
	cd ../
fi

echo
echo "Your temporary files will be stored in ${TMP_PATH}"

# Check whether the input sequences are gzipped or not
FASTACHECK=$(file ${QUERY_FASTA} | cut -d " " -f2)

if [[ ${FASTACHECK} == "symbolic" ]]; then
	QUERY_REALPATH=$(ls -l ${QUERY_FASTA} | awk '{ print $11 }')
	QUERY_FASTA="${QUERY_REALPATH}"
	FASTACHECK=$(file ${QUERY_FASTA} | cut -d " " -f2)
fi

if [[ ${FASTACHECK} == "gzip" ]]; then
	zcat < ${QUERY_FASTA} > ${TMP_PATH}/tmp_${NCBITAX}_sequences
	QUERY_FASTA="${TMP_PATH}/tmp_${NCBITAX}_sequences"
fi

QUERYSIZE1=$(grep -c ">" ${QUERY_FASTA})
QUERYSIZE2=$(wc -l ${QUERY_FASTA} | cut -d" " -f1)
if [ "$QUERYSIZE1" -lt 1 ] || [ "$QUERYSIZE2" -lt 2 ]; then
	echo
	echo "  ERROR: The protein sequences in ${QUERY_FASTA} are not in FASTA format, or the file is empty"
	print_usage >&2; exit 1
fi

#######################################################
###                 GenEra: STEP 1                  ###
#######################################################

if [ -n "$DIAMONDOUT" ]; then

	# Check that the pre-generated DIAMOND file exists
	if [[ ! -f ${DIAMONDOUT} ]]; then
		echo
		echo "  ERROR: genEra could not find the pre-generated DIAMOND/MMseqs2 file:"
		echo "  ${DIAMONDOUT}"
		echo "  Exiting"
		exit 1
	fi

	echo
	echo "DIAMOND/MMSEQS2 OUTPUT ALREADY GENERATED. SKIPPING STEP 1"
	echo
	echo "We're just going to quickly match the query genes against themselves for later on (step 3)"

	# Generate DIAMOND database for self-match
	diamond makedb \
	 --in ${QUERY_FASTA} \
	 --db ${TMP_PATH}/tmp_selfmatch_db --quiet

	# Create a self-match table for the clustering analysis
	diamond blastp --${SENSITIVITY} \
	 --query ${QUERY_FASTA} \
	 --db ${TMP_PATH}/tmp_selfmatch_db \
	 --outfmt 6 qseqid sseqid evalue bitscore \
	 --evalue ${EVALUE} --max-target-seqs 0 \
	 --threads ${THREADS} --out ${TMP_PATH}/tmp_${NCBITAX}_self_matches.bout --quiet ${DIAMONDOPTS}

	# Create input file for MCL
	cut -f 1,2,3 ${TMP_PATH}/tmp_${NCBITAX}_self_matches.bout > ${TMP_PATH}/tmp_${NCBITAX}.abc

	# Remove temporary files
	rm ${TMP_PATH}/tmp_selfmatch_db* ${TMP_PATH}/tmp_${NCBITAX}_self_matches.bout

else

	if [[ ! -f ${NR_DB}.dmnd ]]; then
		echo
		echo "  ERROR: genEra could not find the locally installed NR database for DIAMOND:"
		echo "  ${NR_DB}.dmnd"
		echo "  Please refer to the manual for information on how to generate such database"
		echo "  Exiting"
		exit 1
	fi

	echo
	echo "STARTING STEP 1: SEARCHING FOR HOMOLOGS WITHIN THE DATABASE USING DIAMOND"

	# Check whether DIAMOND can be found by genEra
	DIAMONDPATH=$(which diamond)
	 if [[ -z ${DIAMONDPATH} ]]; then
		echo
		echo "  ERROR: genEra could not find the diamond excecutable. Unable to run step 1"
		echo "  Please make sure that DIAMOND is properly installed and located in the PATH"
		echo "  Exiting"
		exit 1
	fi

	echo "--------------------------------------------------"
	echo "Matching the query genes against themselves"

	# Generate DIAMOND database for self-match
	diamond makedb \
	 --in ${QUERY_FASTA} \
	 --db ${TMP_PATH}/tmp_selfmatch_db --quiet

	# Create a self-match table to find orphan genes and for the clustering analysis
	diamond blastp --${SENSITIVITY} \
	 --query ${QUERY_FASTA} \
	 --db ${TMP_PATH}/tmp_selfmatch_db \
	 --outfmt 6 qseqid sseqid evalue bitscore \
	 --evalue ${EVALUE} --max-target-seqs 0 \
	 --threads ${THREADS} --out ${TMP_PATH}/tmp_${NCBITAX}_self_matches.bout --quiet ${DIAMONDOPTS}

	# Create input file for MCL
	cut -f 1,2,3 ${TMP_PATH}/tmp_${NCBITAX}_self_matches.bout > ${TMP_PATH}/tmp_${NCBITAX}.abc

	# Add the self-matches to the homology table
	awk -v NCBITAX="$NCBITAX" '{ print $0"\t"NCBITAX }' ${TMP_PATH}/tmp_${NCBITAX}_self_matches.bout > ${TMP_PATH}/${NCBITAX}_Diamond_results.bout

	# Remove temporary files
	rm ${TMP_PATH}/tmp_selfmatch_db* ${TMP_PATH}/tmp_${NCBITAX}_self_matches.bout

	echo "--------------------------------------------------"
	echo "Searching for homologs against the NR database"

	# Search for hits between the query species and the nr
	diamond blastp --${SENSITIVITY} \
	 --query ${QUERY_FASTA} \
	 --db ${NR_DB} \
	 --outfmt 6 qseqid sseqid evalue bitscore staxids \
	 --evalue ${EVALUE} --max-target-seqs 0 \
	 --threads ${THREADS} --out ${TMP_PATH}/${NCBITAX}_Diamond_prefiltered_results.bout --quiet ${DIAMONDOPTS}

	# Remove hits that do not have any associated taxids
	awk '$5!=""' ${TMP_PATH}/${NCBITAX}_Diamond_prefiltered_results.bout >> ${TMP_PATH}/${NCBITAX}_Diamond_results.bout
	rm ${TMP_PATH}/${NCBITAX}_Diamond_prefiltered_results.bout

	# Look for homologs in a custom protein database
	if [ -n "$CUSTOMDATA" ]; then

		if [[ -f ${CUSTOMDATA} ]]; then

			echo "--------------------------------------------------"
			echo "Custom protein database found. Searching for homologs in the custom database using DIAMOND"

			# Generate a list of all gene names with their respective taxid, and generate a custom FASTA file with all custom sequences
			IFS=$'\n'
			for SPECIES in $(cat ${CUSTOMDATA}); do
				SP_FASTA=$(echo $SPECIES | cut -d "	" -f1)
				SP_TAXID=$(echo $SPECIES | cut -d "	" -f2)

				FASTACHECK=$(file ${SP_FASTA} | cut -d " " -f2)

				if [[ ${FASTACHECK} == "symbolic" ]]; then
					FASTA_REALPATH=$(ls -l ${SP_FASTA} | awk '{ print $11 }')
					SP_FASTA="${FASTA_REALPATH}"
					FASTACHECK=$(file ${SP_FASTA} | cut -d " " -f2)
				fi

				if [[ ${FASTACHECK} == "gzip" ]]; then
					zcat < ${SP_FASTA} > ${TMP_PATH}/tmp_${SP_TAXID}_proteins
					${SP_FASTA}="${TMP_PATH}/tmp_${SP_TAXID}_proteins"
				fi

				grep ">" ${SP_FASTA} | awk '{ print $1 }' | sed 's/>//g' | sed "s/$/\t${SP_TAXID}/" >> ${TMP_PATH}/tmp_custom_taxid_table
				cat ${SP_FASTA} >> ${TMP_PATH}/tmp_custom_database.fasta

				if [[ -f ${TMP_PATH}/tmp_${SP_TAXID}_proteins ]]; then
					rm ${TMP_PATH}/tmp_${SP_TAXID}_proteins
				fi
			done

			# Generate DIAMOND custom database
			diamond makedb \
			 --in ${TMP_PATH}/tmp_custom_database.fasta \
			 --db ${TMP_PATH}/tmp_custom_database --quiet

			# Search for hits against the custom database
			diamond blastp --${SENSITIVITY} \
			 --query ${QUERY_FASTA} \
			 --db ${TMP_PATH}/tmp_custom_database \
			 --outfmt 6 qseqid sseqid evalue bitscore \
			 --evalue ${EVALUE} --max-target-seqs 0 \
			 --threads ${THREADS} --out ${TMP_PATH}/${NCBITAX}_custom_DB.bout --quiet ${DIAMONDOPTS}

			# Add the taxids to the results of the custom database and merge them with the nr results
			awk '{ print $2 }' ${TMP_PATH}/${NCBITAX}_custom_DB.bout > ${TMP_PATH}/tmp_sseqids
			awk 'NR==FNR{a[$1]=$2;next}{print $0,a[$1]}' ${TMP_PATH}/tmp_custom_taxid_table ${TMP_PATH}/tmp_sseqids > ${TMP_PATH}/tmp_sseqids_taxids
			awk '{ print $2 }' ${TMP_PATH}/tmp_sseqids_taxids | paste -d "\t" ${TMP_PATH}/${NCBITAX}_custom_DB.bout - | awk '$5!=""' >> ${TMP_PATH}/${NCBITAX}_Diamond_results.bout
			rm ${TMP_PATH}/tmp_custom_taxid_table ${TMP_PATH}/tmp_custom_database* ${TMP_PATH}/tmp_sseqids ${TMP_PATH}/tmp_sseqids_taxids ${TMP_PATH}/${NCBITAX}_custom_DB.bout

		else

			# In case the file does not exist, skip this step
			echo "--------------------------------------------------"
			echo "  ERROR: The user specified a custom protein database, but the following file does not exist:"
			echo "  ${CUSTOMDATA}"
			echo "  genEra will continue without including the custom protein database"

		fi

	fi

	if [ -n "$CUSTOMGENOMES" ]; then

		if [[ -f ${CUSTOMGENOMES} ]]; then

			echo "--------------------------------------------------"
			echo "Custom nucleotide database found. Searching proteins against nucleotides using MMseqs2"

			# Check whether MMseqs2 can be found by genEra (This will not result in exit 1)
			MMSEQSPATH=$(which mmseqs)
			if [[ -z ${MMSEQSPATH} ]]; then
				echo
				echo "  ERROR: genEra could not find mmseqs in the PATH"
				echo "  Please make sure to install MMseqs2 before using a custom nucleotide database"
			fi

			# Generate a list of all the genome contigs with their respective taxid, and generate a custom FASTA file with all the custom genomes
			IFS=$'\n'
			for SPECIES in $(cat ${CUSTOMGENOMES}); do
				SP_FASTA=$(echo $SPECIES | cut -d "	" -f1)
				SP_TAXID=$(echo $SPECIES | cut -d "	" -f2)

				FASTACHECK=$(file ${SP_FASTA} | cut -d " " -f2)

				if [[ ${FASTACHECK} == "symbolic" ]]; then
					FASTA_REALPATH=$(ls -l ${SP_FASTA} | awk '{ print $11 }')
					SP_FASTA="${FASTA_REALPATH}"
					FASTACHECK=$(file ${SP_FASTA} | cut -d " " -f2)
				fi

				if [[ ${FASTACHECK} == "gzip" ]]; then
					zcat < ${SP_FASTA} > ${TMP_PATH}/tmp_${SP_TAXID}_nucleotides
					SP_FASTA="${TMP_PATH}/tmp_${SP_TAXID}_nucleotides"
				fi

				grep ">" ${SP_FASTA} | awk '{ print $1 }' | sed 's/>//g' | sed "s/$/\t${SP_TAXID}/" >> ${TMP_PATH}/tmp_custom_genome_taxid_table
				cat ${SP_FASTA} >> ${TMP_PATH}/tmp_custom_genome_database.fasta

				if [[ -f ${TMP_PATH}/tmp_${SP_TAXID}_nucleotides ]]; then
					rm ${TMP_PATH}/tmp_${SP_TAXID}_nucleotides
				fi
			done

			mkdir ${TMP_PATH}/tmp_mmseqs

			# Create databases for mmseqs
			mmseqs createdb ${QUERY_FASTA} ${TMP_PATH}/tmp_${NCBITAX}_DB --dbtype 1 > mmseqs2_log_${NCBITAX}
			mmseqs createdb ${TMP_PATH}/tmp_custom_genome_database.fasta ${TMP_PATH}/tmp_genome_DB --dbtype 2 >> mmseqs2_log_${NCBITAX}

			# Search the query proteins against the genome assemblies in a "tblastn" fashion
			mmseqs search ${TMP_PATH}/tmp_${NCBITAX}_DB ${TMP_PATH}/tmp_genome_DB ${TMP_PATH}/tmp_aln ${TMP_PATH}/tmp_mmseqs --threads ${THREADS} -e ${EVALUE} --split-memory-limit 100G -s 7.5 >> mmseqs2_log_${NCBITAX}
			mmseqs convertalis ${TMP_PATH}/tmp_${NCBITAX}_DB ${TMP_PATH}/tmp_genome_DB ${TMP_PATH}/tmp_aln ${TMP_PATH}/${NCBITAX}_custom_genome_DB.bout --format-output "query,target,evalue,bits" >> mmseqs2_log_${NCBITAX}

			awk '{ print $2 }' ${TMP_PATH}/${NCBITAX}_custom_genome_DB.bout > ${TMP_PATH}/tmp_genome_sseqids
			awk 'NR==FNR{a[$1]=$2;next}{print $0,a[$1]}' ${TMP_PATH}/tmp_custom_genome_taxid_table ${TMP_PATH}/tmp_genome_sseqids > ${TMP_PATH}/tmp_genome_sseqids_taxids
			awk '{ print $2 }' ${TMP_PATH}/tmp_genome_sseqids_taxids | paste -d "\t" ${TMP_PATH}/${NCBITAX}_custom_genome_DB.bout - | awk '$5!=""' >> ${TMP_PATH}/${NCBITAX}_Diamond_results.bout
			rm ${TMP_PATH}/tmp_custom_genome_taxid_table ${TMP_PATH}/tmp_custom_genome_database.fasta ${TMP_PATH}/tmp_${NCBITAX}_DB* ${TMP_PATH}/tmp_genome_DB* ${TMP_PATH}/tmp_aln* ${TMP_PATH}/tmp_genome_sseqids_taxids ${TMP_PATH}/tmp_genome_sseqids ${TMP_PATH}/${NCBITAX}_custom_genome_DB.bout
			rm -r ${TMP_PATH}/tmp_mmseqs/

		else

			echo "--------------------------------------------------"
			echo "  ERROR: The user specified a custom nucleotide database, but the following file does not exist:"
			echo "  ${CUSTOMGENOMES}"
			echo "  genEra will continue without including the custom nucleotide database"

		fi

	fi

	DIAMONDOUT="${TMP_PATH}/${NCBITAX}_Diamond_results.bout"

	echo "--------------------------------------------------"
	echo "Step 1 finished!"
	echo "The DIAMOND/MMseqs2 table can be found in ${DIAMONDOUT}"
	echo "This file is usually HUGE, please dispose of it if you no longer find it useful"
	echo "It can still be used (-p) in case the user wants to re-run genEra while skipping step 1"

fi

#######################################################
###                 GenEra: STEP 2                  ###
#######################################################

# Generate a taxonomic database based on the daxdump from the NCBI and the output of ncbitax2lin
if [ -n "$CUSTOMTAX" ]; then

	echo
	echo "THE SPECIES-TAILORED TAXONOMIC DATABASE WAS PROVIDED BY THE USER. SKIPPING STEP 2"

else

	echo
	echo "STARTING STEP 2: GENERATING TAXONOMIC DATABASE FOR THE PHYLOSTRATIGRAPHIC ASSIGNMENT OF YOUR GENES"

	if [ -n "$RAWTAX" ]; then

		echo "--------------------------------------------------"
		echo "Using the raw \"ncbi_lineages\" file provided by the user. Skiping ncbitax2lin"

	else
		# Check whether ncbitax2lin exists in the PATH
		TAX2LINPATH=$(which ncbitax2lin)
		if [[ -z ${TAX2LINPATH} ]]; then
			echo
			echo "  ERROR: The user attempted to generate the raw \"ncbi_lineages\" file from the NCBI taxdump, but genEra could not find the ncbitax2lin excecutable. Unable to run step 2"
			echo "  Please ensure that ncbitax2lin is correctly installed in your PATH and try again"
			echo "  Or try to use an already existing \"ncbi_lineages\" file with argument -r"
			echo "  The user can resume genEra from this step by including the DIAMOND/MMseqs2 file ${DIAMONDOUT} in the pipeline (-p)"
			exit 1
		fi


		echo "--------------------------------------------------"
		echo "Running ncbitax2lin to generate a raw \"ncbi_lineages\" file from the NCBI taxdump"

		# Verify that the taxdump contains the necessary files to run ncbitax2lin
		if [[ ! -f ${TAXDUMP}/nodes.dmp ]] || [[ ! -f ${TAXDUMP}/names.dmp ]]; then
			echo
			echo "  ERROR: genEra could not find \"nodes.dmp\" and/or \"names.dmp\" within the specified taxdump directory:"
			echo "  ${TAXDUMP}/"
			echo "  Please ensure that the route to the daxdump directory is correct, and that both files exist within that directory"
			echo "  Or try to use an already existing \"ncbi_lineages\" file with argument -r"
			echo "  The user can resume genEra from this step by including the DIAMOND/MMseqs2 file ${DIAMONDOUT} in the pipeline (-p)"
			exit 1
		fi

		# Generate the raw ncbi_lineages file with ncbitax2lin
		ncbitax2lin --nodes-file ${TAXDUMP}/nodes.dmp --names-file ${TAXDUMP}/names.dmp
		gunzip ncbi_lineages_*.csv.gz
		RAWTAX=$(ls ncbi_lineages_*.csv)

		echo "--------------------------------------------------"
		echo "Finished generating a raw \"ncbi_lineages\" file named ${RAWTAX}"
		echo "Keep it in case you want to run genEra with another species (-r)"

	fi

	# Verify that the raw ncbi_lineages file exists
	if [[ ! -f ${RAWTAX} ]]; then
		echo
		echo "  ERROR: genEra could not find the raw \"ncbi_lineages\" file:"
		echo "  ${RAWTAX}"
		echo "  If step 1 ran succesfully, the user can resume from this step using the argument -p"
		echo "  Exiting"
		exit 1
	fi

	echo "--------------------------------------------------"
	echo "Rearranging the raw \"ncbi_lineages\" file by taxonomic hierarchy"
	echo "--------------------------------------------------"

	# Extract the line in the "ncbi_lineages" file corresponding to the query organism
	QPHYLOS=$(awk -F "," -v NCBITAX="$NCBITAX" '{ if ($1 == NCBITAX) print $0 }' ${RAWTAX})

	# Download the correct lineage hierarchy of the query species directly from the NCBI webpage
	wget "https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?mode=Info&id=${NCBITAX}&lvl=3&p=has_linkout&p=blast_url&p=genome_blast&lin=f&keep=1&srchmode=1&unlock"

	if [[ -f wwwtax.cgi\?mode\=Info\&id\=${NCBITAX}\&lvl\=3\&p\=has_linkout\&p\=blast_url\&p\=genome_blast\&lin\=f\&keep\=1\&srchmode\=1\&unlock ]]; then

		# Create an array which contains the column numbers corresponding to the phylostrata of the query species
		LINEAGE_ARRAY=()
		IFS=$'\n'
		for LINEAGE in $(grep "ALT=\"no rank" wwwtax.cgi\?mode\=Info\&id\=${NCBITAX}\&lvl\=3\&p\=has_linkout\&p\=blast_url\&p\=genome_blast\&lin\=f\&keep\=1\&srchmode\=1\&unlock | sed 's/>/\n/g' | grep "</a" | sed 's/<\/a//g' | grep -v "incertae sedis"); do
			LINEAGE_ARRAY+=($(echo ${QPHYLOS} | sed -n $'1s/,/\\\n/gp' | grep -nx "$LINEAGE" | cut -d: -f1 && echo))
		done
		TOP_LEVEL=$(grep "<title>Taxonomy browser" wwwtax.cgi\?mode\=Info\&id\=${NCBITAX}\&lvl\=3\&p\=has_linkout\&p\=blast_url\&p\=genome_blast\&lin\=f\&keep\=1\&srchmode\=1\&unlock | sed 's/  <title>Taxonomy browser (//g' | sed 's/)<\/title>//g')
		LINEAGE_ARRAY+=($(echo ${QPHYLOS} | sed -n $'1s/,/\\\n/gp' | grep -nx "$TOP_LEVEL" | cut -d: -f1 && echo))

		# Extract the columns in "ncbi_lineages" in the correct hierarchical order
		touch ${TMP_PATH}/tmp_column_0
		PRINTCOLUMN="${TMP_PATH}/tmp_column_0"

		for LINEAGECOL in "${LINEAGE_ARRAY[@]}"; do
			awk -F'"' -v OFS='' '{ for (i=2; i<=NF; i+=2) gsub(",", "", $i) } 1' ${RAWTAX} | awk -F "," -v LINEAGECOL="$LINEAGECOL" '{ print $LINEAGECOL }' | paste -d , - ${PRINTCOLUMN} > ${TMP_PATH}/tmp_column_${LINEAGECOL}
			PRINTCOLUMN="${TMP_PATH}/tmp_column_${LINEAGECOL}"
		done
		awk -F'"' -v OFS='' '{ for (i=2; i<=NF; i+=2) gsub(",", "", $i) } 1' ${RAWTAX} | awk -F "," '{ print $1 }' | paste -d , - ${PRINTCOLUMN} | sed 's/,$//' > ${TMP_PATH}/tmp_arranged_${RAWTAX}

		rm wwwtax* ${TMP_PATH}/tmp_column_*

		# Extract the philostrata corresponding to the query organism
		QPHYLOS=$(awk -F "," -v NCBITAX="$NCBITAX" '{ if ($1 == NCBITAX) print $0 }' ${TMP_PATH}/tmp_arranged_${RAWTAX})

		# Extract all the lineages proteins that matched the query sequences under a certain threshold and that belong to the same oldest lineage of the query species (e.g., "cellular organisms")
		GENENUM=$(grep -c ">" ${QUERY_FASTA})
		OLDEST=$(echo $QPHYLOS | awk -F "," '{ print $NF }')

		echo "--------------------------------------------------"
		echo "Extracting all the lineages that mached more than ${MINHITS} percent of your query proteins"

		awk '{ print $NF }' ${DIAMONDOUT} | sort -n | uniq -c | awk -v MINHITS="$MINHITS" -v GENENUM="$GENENUM" '{ if (GENENUM/$1 < MINHITS) print $2 }' | sed '/^[[:space:]]*$/d' | awk -F "," 'FNR==NR{ a[$1]=$0;next } ($1 in a)' - ${TMP_PATH}/tmp_arranged_${RAWTAX} | grep "$OLDEST" > ${TMP_PATH}/tmp_${NCBITAX}_matches

		# Finally, tailor the taxonomic database for the query species with the phylostrata that are useful for the analysis
		COUNTER=2

		echo "--------------------------------------------------"
		echo "Collapsing the phylostrata that are not represented in your DIAMOND results"
		cat ${TMP_PATH}/tmp_${NCBITAX}_matches > ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches
		ARRAY=()
		COLLAPSEDSTRATA=()

		IFS=$'\n'
		for STRATUM in $(echo $QPHYLOS | sed "s/,/\n/g" | tail -n +2); do

			MATCHINGTAXA=$(awk -F "," -v COUNTER="$COUNTER" -v STRATUM="$STRATUM" '{ if ($COUNTER == STRATUM) print $0 }' ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches | wc -l)
			if [ "$MATCHINGTAXA" -ge 1 ]; then
				awk -F "," -v COUNTER="$COUNTER" -v STRATUM="$STRATUM" '{ if ($COUNTER != STRATUM) print $0 }' ${TMP_PATH}/tmp_${NCBITAX}_matches > ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches
				ARRAY+=$COUNTER,
			else
				COLLAPSEDSTRATA+="[${STRATUM}] "
			fi
			let COUNTER+=1

		done

		if [ ${#COLLAPSEDSTRATA[@]} -gt 0 ]; then

			echo "--------------------------------------------------"
			echo "  WARNING: The following phylostrata were collapsed due to lack of sufficient genomic data:"
			echo "  $COLLAPSEDSTRATA"
			echo "  If you want to include them in your analysis, please add the necessary taxa in a custom database (-a or -f), making sure their last common ancestor to the query species can be assigned to that specific taxonomic level in the NCBI taxonomy database"

		fi

		echo "--------------------------------------------------"
		echo "Generating the species-tailored database"

		awk -F "," '{ print $1 }' ${TMP_PATH}/tmp_arranged_${RAWTAX} > ${TMP_PATH}/tmp_${NCBITAX}_${RAWTAX}
		PRINTCOLUMN="${TMP_PATH}/tmp_${NCBITAX}_${RAWTAX}"

		for LEVEL in $(echo $ARRAY | sed "s/,/\n/g" | sed '/^[[:space:]]*$/d'); do
			awk -F "," -v LEVEL="$LEVEL" '{ print $LEVEL }' ${TMP_PATH}/tmp_arranged_${RAWTAX} | paste -d , ${PRINTCOLUMN} - > ${TMP_PATH}/tmp_column_${LEVEL}
			PRINTCOLUMN="${TMP_PATH}/tmp_column_${LEVEL}"
		done

		cat ${PRINTCOLUMN} > ${NCBITAX}_${RAWTAX}

		rm ${TMP_PATH}/tmp_arranged_${RAWTAX} ${TMP_PATH}/tmp_${NCBITAX}_${RAWTAX} ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches ${TMP_PATH}/tmp_${NCBITAX}_matches ${TMP_PATH}/tmp_column_*

		CUSTOMTAX="${NCBITAX}_${RAWTAX}"

	else

		echo "--------------------------------------------------"
		echo "  ERROR: genEra was unable to download the lineage information of your query species from the NCBI webpage"
		echo "  genEra will work offline and attempt to organize the phylostrata in the correct taxonomic hierarchy"
		echo "  This may result in the loss of some phylostrata from the species-tailored database"

		# Eliminate the inner commas from some of the taxa in the raw file and arrange the lineages by taxonomic hierarchies
		awk -F'"' -v OFS='' '{ for (i=2; i<=NF; i+=2) gsub(",", "", $i) } 1' ${RAWTAX} | awk -F "," '{ print $1","$8","$52","$51","$57","$7","$63","$68","$56","$6","$65","$45","$36","$59","$5","$66","$55","$30","$35","$54","$4","$64","$60","$3","$67","$58","$38","$2","$40 }' > ${TMP_PATH}/tmp_arranged_${RAWTAX}

		# Extract the philostrata corresponding to the query organism
		QPHYLOS=$(awk -F "," -v NCBITAX="$NCBITAX" '{ if ($1 == NCBITAX) print $0 }' ${TMP_PATH}/tmp_arranged_${RAWTAX})

		# Extract all the lineages proteins that matched the query sequences under a certain threshold and that belong to the same oldest lineage of the query species (e.g., "cellular organisms")
		GENENUM=$(grep -c ">" ${QUERY_FASTA})
		OLDEST=$(echo $QPHYLOS | awk -F "," '{ print $NF }')

		awk '{ print $NF }' ${DIAMONDOUT} | sort -n | uniq -c | awk -v MINHITS="$MINHITS" -v GENENUM="$GENENUM" '{ if (GENENUM/$1 < MINHITS) print $2 }' | sed '/^[[:space:]]*$/d' | awk -F "," 'FNR==NR{ a[$1]=$0;next } ($1 in a)' - ${TMP_PATH}/tmp_arranged_${RAWTAX} | grep "$OLDEST" > ${TMP_PATH}/tmp_${NCBITAX}_matches

		#Evaluate the existance of unassignable clades in the database
		MISSINGSTRATA=()
		awk -F "," -v NCBITAX="$NCBITAX" '{ if ($1 == NCBITAX) print $10","$11","$12","$13","$14","$15","$16","$17","$18","$19","$20","$21","$22","$23","$24","$25","$26","$27","$28","$29","$41","$42","$43","$44 }' ${RAWTAX} > ${TMP_PATH}/tmp_missingtaxa_${NCBITAX}

		IFS=$'\n'
		for MISSING in $(sed "s/,/\n/g" ${TMP_PATH}/tmp_missingtaxa_${NCBITAX}); do

			if [ -n "$MISSING" ]; then
				MISSINGSTRATA+="[${MISSING}] "
			fi
		done

		if [ ${#MISSINGSTRATA[@]} -gt 0 ]; then

			echo "--------------------------------------------------"
			echo "  WARNING: genEra was unable to automatically include the following phylostrata in the analysis, as the NCBI database did not assigned them to a concrete taxonomic level:"
			echo "  $MISSINGSTRATA"
			echo "  If you want to include them in your analysis, make sure that genEra runs in a machine with internet access"
			echo "  Alternatively, the user can generate a custom table (-c) directly from the raw \"ncbi_lineages\" file, using the following command:"
			echo "  awk -F'\"' -v OFS='' '{ for (i=2; i<=NF; i+=2) gsub(\",\", \"\", \$i) } 1' ncbi_lineages_[date].csv | awk -F \",\" '{ print \$1\",\"\$8\",\"\$7\",\"\$6 ... }' > custom_table.csv"

		fi

		# Finally, tailor the taxonomic database for the query species with the phylostrata that are useful for the analysis
		COUNTER=2

		echo "--------------------------------------------------"
		echo "Collapsing the phylostrata that are not represented in your DIAMOND results"
		cat ${TMP_PATH}/tmp_${NCBITAX}_matches > ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches
		ARRAY=()
		COLLAPSEDSTRATA=()

		IFS=$'\n'
		for STRATUM in $(echo $QPHYLOS | sed 's/,,/,NA,/g' | sed 's/,,/,NA,/g' | sed "s/,/\n/g" | tail -n +2); do

			if [ $STRATUM != "NA" ]; then

				 MATCHINGTAXA=$(awk -F "," -v COUNTER="$COUNTER" -v STRATUM="$STRATUM" '{ if ($COUNTER == STRATUM) print $0 }' ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches | wc -l)
				if [ "$MATCHINGTAXA" -ge 1 ]; then
					awk -F "," -v COUNTER="$COUNTER" -v STRATUM="$STRATUM" '{ if ($COUNTER != STRATUM) print $0 }' ${TMP_PATH}/tmp_${NCBITAX}_matches > ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches
					ARRAY+=$COUNTER,
				else
					COLLAPSEDSTRATA+="[${STRATUM}] "
				fi
			fi
			let COUNTER+=1

		done

		if [ ${#COLLAPSEDSTRATA[@]} -gt 0 ]; then

			echo "--------------------------------------------------"
			echo "  WARNING: The following phylostrata were collapsed due to lack of sufficient genomic data"
			echo "  $COLLAPSEDSTRATA"
			echo "  If you want to include them in your analysis, please add the necessary taxa in a custom database (-a or -f), making sure their last common ancestor to the query species can be assigned to that specific taxonomic level in the NCBI taxonomy database"

		fi

		echo "--------------------------------------------------"
		echo "Generating the species-tailored database"

		awk -F "," '{ print $1 }' ${TMP_PATH}/tmp_arranged_${RAWTAX} > ${TMP_PATH}/tmp_${NCBITAX}_${RAWTAX}
		PRINTCOLUMN="${TMP_PATH}/tmp_${NCBITAX}_${RAWTAX}"

		for LEVEL in $(echo $ARRAY | sed "s/,/\n/g" | sed '/^[[:space:]]*$/d'); do

			awk -F "," -v LEVEL="$LEVEL" '{ print $LEVEL }' ${TMP_PATH}/tmp_arranged_${RAWTAX} | paste -d , ${PRINTCOLUMN} - > ${TMP_PATH}/tmp_column_${LEVEL}
			PRINTCOLUMN="${TMP_PATH}/tmp_column_${LEVEL}"
		done

		cat ${PRINTCOLUMN} > ${NCBITAX}_${RAWTAX}

		rm ${TMP_PATH}/tmp_arranged_${RAWTAX} ${TMP_PATH}/tmp_${NCBITAX}_${RAWTAX} ${TMP_PATH}/tmp_${NCBITAX}_trimmed_matches ${TMP_PATH}/tmp_${NCBITAX}_matches ${TMP_PATH}/tmp_column_* ${TMP_PATH}/tmp_missingtaxa_${NCBITAX}

		CUSTOMTAX="${NCBITAX}_${RAWTAX}"

	fi

	echo "--------------------------------------------------"
	echo "Step 2 finished!"
	echo "your species-tailored database can be found in ${NCBITAX}_${RAWTAX}"
	echo "Keep this file in case you want to re-run step 3 of genEra with the same species (-c)"

fi

if [[ ! -f ${CUSTOMTAX} ]]; then
	echo
	echo "  ERROR: genEra could not find the species-tailored \"ncbi_lineages\" file:"
	echo "  ${CUSTOMTAX}"
	echo "  Please make sure that this file exists, otherwise run step 2 of genEra (-d or -r)"
	echo "  If step 1 ran succesfully, the user can resume from this step using argument -p"
	echo "  Exiting"
	exit 1
fi

#######################################################
###                 GenEra: STEP 3                  ###
#######################################################

# Start the phylostratigraphy analysis
echo
echo "STARTING STEP 3: ASSIGNING AGES TO YOUR QUERY GENES WITH Erassignment"

# Generate temporal list with all query proteins from step 1
grep ">" ${QUERY_FASTA} | awk '{ print $1 }' | sed 's/>//g' > ${TMP_PATH}/tmp_gene_list

if [[ -f ${DIVERGENCE} ]]; then

	# Calculate the size of the genes in the query FASTA file
	echo -e "GeneID\tGeneLength" > ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths
	awk '/^>/{if (l!="") print l; print; l=0; next}{l+=length($0)}END{print l}' ${QUERY_FASTA} | awk '{ print $1 }' | sed '$!N;s/\n/\t/g' | sed 's/>//g' >> ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths

	# Create header of the bitscore file for abSENSE
	awk  '{ printf( "%s ", $1 ); } END { printf( "\n" ); }' ${DIVERGENCE} | sed 's/[[:space:]]*$//' | sed 's/ /\t/g' | sed -e 's/^/None\t/' > ${NCBITAX}_bitscores.tsv

fi

# Split the gene list in accordance to the number of threads
if [ $THREADS -gt 1 ]; then
	SPLIT_NUM=$(wc -l ${TMP_PATH}/tmp_gene_list | cut -d' ' -f1 | while read number; do  echo $((number / $THREADS +1)); done)
	split -l $SPLIT_NUM ${TMP_PATH}/tmp_gene_list ${TMP_PATH}/tmp_gene_sublist_

	# Create modified copies of Erassignment, according to the number of threads
	MULTITHREAD_COUNTER=1
	for SUBLIST in $(ls ${TMP_PATH} | grep "tmp_gene_sublist_"); do
		sed "s/tmp_gene_list/$SUBLIST/g" ${PHYLOSCRIPT} | sed "s/tmp_phylostrata/tmp_phylostrata_$MULTITHREAD_COUNTER/g" | sed "s/tmp_sub_phylostrata/tmp_sub_phylostrata_$MULTITHREAD_COUNTER/g" > ${TMP_PATH}/Erassignment_$MULTITHREAD_COUNTER && chmod +x ${TMP_PATH}/Erassignment_$MULTITHREAD_COUNTER
		let MULTITHREAD_COUNTER+=1
	done

	# Print the header of the output files
	echo -e "#gene\tphylostratum\trank\ttaxonomic_representativeness" > ${NCBITAX}_gene_ages.tsv
	echo -e "#gene\tpossible_phylostrata" > ${NCBITAX}_ambiguous_phylostrata.tsv
	if [[ "${PRINTOLDEST}" = "true" ]]; then
		echo -e "#qseqid\tsseqid\tevalue\tbitscore\tstaxids" > ${NCBITAX}_deepest_homolog.tsv
	fi

	# Run the mutithreaded phylostratigraphic assignment

	echo "--------------------------------------------------"
	echo "Running Erassignment using ${THREADS} threads"

	for SUBSCRIPT in $(ls ${TMP_PATH}/Erassignment_*); do
		${SUBSCRIPT} ${DIAMONDOUT} ${CUSTOMTAX} ${NCBITAX} ${THRESHOLD} ${TMP_PATH} ${PRINTOLDEST} ${DIVERGENCE} &
	done
	wait
	rm ${TMP_PATH}/Erassignment_*
	sort ${NCBITAX}_gene_ages.tsv > tmp_assignment && mv tmp_assignment ${NCBITAX}_gene_ages.tsv
	if [[ "${PRINTOLDEST}" = "true" ]]; then
		sort ${NCBITAX}_deepest_homolog.tsv > tmp_deepest_homolog && mv tmp_deepest_homolog ${NCBITAX}_deepest_homolog.tsv
	fi

# Otherwise run as single-threaded job (not recommended)
else

	echo "--------------------------------------------------"
	echo "Running Erassignment using a single thread"
	echo "This WILL take a while"

	echo -e "#gene\tphylostratum\trank\ttaxonomic_representativeness" > ${NCBITAX}_gene_ages.tsv
	echo -e "#gene\tpossible_phylostrata" > ${NCBITAX}_ambiguous_phylostrata.tsv
	if [[ "${PRINTOLDEST}" = "true" ]]; then
		echo -e "#qseqid\tsseqid\tevalue\tbitscore\tstaxids" > ${NCBITAX}_deepest_homolog.tsv
	fi

	Erassignment ${DIAMONDOUT} ${CUSTOMTAX} ${NCBITAX} ${THRESHOLD} ${TMP_PATH} ${PRINTOLDEST} ${DIVERGENCE}

fi

# Calculate the number of genes per phylostratum
echo -e "#number_of_genes\tphylostratum\tphylorank" > ${NCBITAX}_gene_age_summary.tsv
QPHYLOS=$(awk -F "," -v NCBITAX="$NCBITAX" '{ if ($1 == NCBITAX) print $0 }' ${CUSTOMTAX})
PHYLORANK=$(echo ${QPHYLOS} | sed "s/,/\n/g" | tail -n +2 | wc -l)
IFS=$'\n'
for STRATUM in $(echo ${QPHYLOS} | sed "s/,/\n/g" | tail -n +2); do
	NUMGENES=$(awk -F "\t" -v STRATUM="$STRATUM" '{ if ($2 == STRATUM) print $0 }' ${NCBITAX}_gene_ages.tsv | wc -l)
	echo -e "${NUMGENES}\t${STRATUM}\t${PHYLORANK}" >> ${NCBITAX}_gene_age_summary.tsv
	let PHYLORANK-=1
done

rm ${TMP_PATH}/tmp_gene_*

if [[ -f ${TMP_PATH}/tmp_${NCBITAX}_sequences ]]; then
	rm ${TMP_PATH}/tmp_${NCBITAX}_sequences
fi

echo "--------------------------------------------------"
echo "Running mcl to define gene families"

# Run MCL to predict gene families from the query self-match in step 1
mcxload -abc ${TMP_PATH}/tmp_${NCBITAX}.abc --stream-mirror --stream-neg-log10 -stream-tf 'ceil(200)' -o ${TMP_PATH}/tmp_${NCBITAX}.mci -write-tab ${TMP_PATH}/tmp_${NCBITAX}.tab
mcl ${TMP_PATH}/tmp_${NCBITAX}.mci -I 1.5 -te ${THREADS} -o ${TMP_PATH}/tmp_${NCBITAX}.mcl -V all
mcxdump -icl ${TMP_PATH}/tmp_${NCBITAX}.mcl -tabr ${TMP_PATH}/tmp_${NCBITAX}.tab -o ${TMP_PATH}/tmp_${NCBITAX}.dump

# Eliminate all the temporary files
rm ${TMP_PATH}/tmp_${NCBITAX}.abc ${TMP_PATH}/tmp_${NCBITAX}.mci ${TMP_PATH}/tmp_${NCBITAX}.tab ${TMP_PATH}/tmp_${NCBITAX}.mcl

echo "--------------------------------------------------"
echo "Establishing the age and number of gene-family founder events"

# Generate a table with the oldest assignable phylostratum per gene family and gene-family size
echo -e "#gene_family\tphylostratum\trank\tfamily_size" > ${NCBITAX}_founder_events.tsv

IFS=$'\n'
for GENECLUSTER in $(cat ${TMP_PATH}/tmp_${NCBITAX}.dump); do

	GENEFAMILY=$(echo ${GENECLUSTER} | sed 's/\t/,/g')
	FAMILYSIZE=$(echo ${GENECLUSTER} | sed 's/\t/\n/g' | wc -l)
	FOUNDER=$(echo ${GENECLUSTER} | sed 's/\t/\n/g' | awk 'FNR==NR{ a[$1]=$0;next } ($1 in a)' - ${NCBITAX}_gene_ages.tsv | sort -t$'\t' -nk3 | grep -v "Possible contamination or HGT" | head -1 | cut -d'	' -f2,3)

	if [[ -z ${FOUNDER} ]]; then
		echo -e "$GENEFAMILY\tPossible contamination or HGT\tNA\t$FAMILYSIZE" >> ${NCBITAX}_founder_events.tsv
	else
		echo -e "$GENEFAMILY\t$FOUNDER\t$FAMILYSIZE" >> ${NCBITAX}_founder_events.tsv
	fi
done

rm ${TMP_PATH}/tmp_${NCBITAX}.dump

# Summarize the number of gene founder events per phylostratum
echo -e "#number_of_founders\tphylostratum\tphylorank" > ${NCBITAX}_founder_summary.tsv
QPHYLOS=$(awk -F "," -v NCBITAX="$NCBITAX" '{ if ($1 == NCBITAX) print $0 }' ${CUSTOMTAX})
PHYLORANK=$(echo ${QPHYLOS} | sed "s/,/\n/g" | tail -n +2 | wc -l)
IFS=$'\n'
for STRATUM in $(echo ${QPHYLOS} | sed "s/,/\n/g" | tail -n +2); do
	NUMFOUNDERS=$(awk -F "\t" -v STRATUM="$STRATUM" '{ if ($2 == STRATUM) print $0 }' ${NCBITAX}_founder_events.tsv | wc -l)
	echo -e "${NUMFOUNDERS}\t${STRATUM}\t${PHYLORANK}" >> ${NCBITAX}_founder_summary.tsv
	let PHYLORANK-=1
done

echo "--------------------------------------------------"
echo "Step 3 finished!"
echo "The age assignment for your individual genes can be found in ${NCBITAX}_gene_ages.tsv"
if [[ "${PRINTOLDEST}" = "true" ]]; then
	echo "The deepest traceable homologs for each of your genes can be found in ${NCBITAX}_deepest_homolog.tsv"
fi
echo "The possible ages for the genes with a taxonomic representativeness below ${THRESHOLD} percent can be found in ${NCBITAX}_ambiguous_phylostrata.tsv"
echo "The estimation of gene family founder events can be found in ${NCBITAX}_founder_events.tsv"
echo "The number of individual genes that could be assigned to each phylostratum is summarized in ${NCBITAX}_gene_age_summary.tsv"
echo "The number of of gene family founder events per phylostratum is summarized in ${NCBITAX}_founder_summary.txt"

#######################################################
###                 GenEra: STEP 4                  ###
#######################################################

# Run abSENSE, if the user invokes it with -s
if [[ -f ${DIVERGENCE} ]]; then

	echo
	echo "STARTING STEP 4: CALCULATING DETECTION FAILURE PROBABILITIES WITH abSENSE.py"

	# Split the input files in accordance to the number of threads
	if [ "${THREADS}" -gt 1 ]; then
		head -1 ${NCBITAX}_bitscores.tsv > ${TMP_PATH}/bitscores_header
		head -1 ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths > ${TMP_PATH}/gene_lengths_header
		tail -n +2 ${NCBITAX}_bitscores.tsv | sort > ${TMP_PATH}/tmp_${NCBITAX}_bitscores
		tail -n +2 ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths | sort > ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_no_header
		split -l $SPLIT_NUM ${TMP_PATH}/tmp_${NCBITAX}_bitscores ${TMP_PATH}/tmp_${NCBITAX}_bitscores_
		split -l $SPLIT_NUM ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_no_header ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_no_header_

		# Rename the input files according to the number of threads
		MULTITHREAD_COUNTER=1
		for SUBLIST in $(ls ${TMP_PATH} | grep "tmp_${NCBITAX}_bitscores_"); do
			SUFIXTMP=$(echo ${SUBLIST} | cut -d "_" -f4)
			cat ${TMP_PATH}/bitscores_header > ${TMP_PATH}/${NCBITAX}_bitscores_${MULTITHREAD_COUNTER}.tsv && cat ${TMP_PATH}/tmp_${NCBITAX}_bitscores_${SUFIXTMP} >> ${TMP_PATH}/${NCBITAX}_bitscores_${MULTITHREAD_COUNTER}.tsv
			cat ${TMP_PATH}/gene_lengths_header > ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_${MULTITHREAD_COUNTER} && cat ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_no_header_${SUFIXTMP}  >> ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_${MULTITHREAD_COUNTER}
			let MULTITHREAD_COUNTER+=1
		done

		# Eliminate all temporary files generated earlier
		rm ${TMP_PATH}/bitscores_header ${TMP_PATH}/gene_lengths_header ${TMP_PATH}/tmp_${NCBITAX}_bitscores ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_no_header ${TMP_PATH}/tmp_${NCBITAX}_bitscores_* ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_no_header_*

		# Run abSENSE using multiple threads

		echo "--------------------------------------------------"
		echo "Running abSENSE using ${THREADS} threads"

		MULTITHREAD_COUNTER=1
		while [[ ${MULTITHREAD_COUNTER} -le ${THREADS} ]]; do
			Run_abSENSE.py --distfile ${DIVERGENCE} --scorefile ${TMP_PATH}/${NCBITAX}_bitscores_${MULTITHREAD_COUNTER}.tsv --Eval ${EVALUE} --genelenfile ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_${MULTITHREAD_COUNTER} --out ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results >> log_${NCBITAX}_abSENSE &
			let MULTITHREAD_COUNTER+=1
		done
		wait

		# Merge all the abSENSE subfiles in a single directory
		mkdir ${NCBITAX}_abSENSE_results
		head -2 ${TMP_PATH}/1_abSENSE_results/Bitscore_99PI_lowerbound_predictions > ${NCBITAX}_abSENSE_results/Bitscore_99PI_lowerbound_predictions
		head -2 ${TMP_PATH}/1_abSENSE_results/Bitscore_99PI_higherbound_predictions > ${NCBITAX}_abSENSE_results/Bitscore_99PI_higherbound_predictions
		head -2 ${TMP_PATH}/1_abSENSE_results/Detection_failure_probabilities > ${NCBITAX}_abSENSE_results/Detection_failure_probabilities
		head -2 ${TMP_PATH}/1_abSENSE_results/Parameter_values > ${NCBITAX}_abSENSE_results/Parameter_values
		head -2 ${TMP_PATH}/1_abSENSE_results/Predicted_bitscores > ${NCBITAX}_abSENSE_results/Predicted_bitscores

		MULTITHREAD_COUNTER=1
		while [[ ${MULTITHREAD_COUNTER} -le ${THREADS} ]]; do
			tail -n +3 ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results/Bitscore_99PI_lowerbound_predictions >> ${NCBITAX}_abSENSE_results/Bitscore_99PI_lowerbound_predictions
			tail -n +3 ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results/Bitscore_99PI_higherbound_predictions >> ${NCBITAX}_abSENSE_results/Bitscore_99PI_higherbound_predictions
			tail -n +3 ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results/Detection_failure_probabilities >> ${NCBITAX}_abSENSE_results/Detection_failure_probabilities
			tail -n +3 ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results/Parameter_values >> ${NCBITAX}_abSENSE_results/Parameter_values
			tail -n +3 ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results/Predicted_bitscores >> ${NCBITAX}_abSENSE_results/Predicted_bitscores
			rm ${TMP_PATH}/${NCBITAX}_bitscores_${MULTITHREAD_COUNTER}.tsv ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths_${MULTITHREAD_COUNTER} ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results/* && rmdir ${TMP_PATH}/${MULTITHREAD_COUNTER}_abSENSE_results
			let MULTITHREAD_COUNTER+=1
		done

		mv log_${NCBITAX}_abSENSE ${NCBITAX}_abSENSE_results/

	# Otherwise run as single-threaded job (not recommended)
	else

		echo "--------------------------------------------------"
		echo "Running abSENSE using a single thread"
		echo "This WILL take another while"

		Run_abSENSE.py --distfile ${DIVERGENCE} --scorefile ${NCBITAX}_bitscores.tsv --Eval ${EVALUE} --genelenfile ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths --out ${NCBITAX}_abSENSE_results > log_${NCBITAX}_abSENSE
		mv log_${NCBITAX}_abSENSE ${NCBITAX}_abSENSE_results/

	fi

	echo "--------------------------------------------------"
	echo "Creating a list of high-confidence gene founder events (homology detection failure probabilities < 0.05 in the closest outgroup)"

	mv ${TMP_PATH}/tmp_${NCBITAX}_gene_lengths ${NCBITAX}_abSENSE_results/${NCBITAX}_gene_lengths.tsv

	# Print the headers for the output file of the high-confidence set of genes based on homology detection failure
	echo -e "#gene\tphylostratum\trank\ttaxonomic_representativeness" > ${NCBITAX}_high_confidence_gene_ages.tsv
	echo -e "#gene_family\tphylostratum\trank\tfamily_size" > ${NCBITAX}_high_confidence_founder_events.tsv

	# Extract the list of phylostrata in the query species
	QPHYLOS=$(awk -F "," -v NCBITAX="$NCBITAX" '{ if ($1 == NCBITAX) print $0 }' ${CUSTOMTAX})
	PHYLORANK=$(echo ${QPHYLOS} | sed "s/,/\n/g" | tail -n +2 | wc -l)

	# Print headers for the summary files
	echo -e "#number_of_genes\tphylostratum\tphylorank\toutgroup" > ${NCBITAX}_high_confidence_gene_age_summary.tsv
	echo ${QPHYLOS} | awk -F "," -v PHYLORANK="$PHYLORANK" '{ print "NA\t"$2"\t"PHYLORANK"\tNA" }' >> ${NCBITAX}_high_confidence_gene_age_summary.tsv
	echo -e "#number_of_founders\tphylostratum\tphylorank\toutgroup" > ${NCBITAX}_high_confidence_founder_summary.tsv
	echo ${QPHYLOS} | awk -F "," -v PHYLORANK="$PHYLORANK" '{ print "NA\t"$2"\t"PHYLORANK"\tNA" }' >> ${NCBITAX}_high_confidence_founder_summary.tsv

	# Create a list with the taxonomy of all the taxa that were included in the list with evolutionary distances
	awk '{ print $1 }' ${DIVERGENCE} | awk -F "," 'FNR==NR{ a[$1]=$0;next } ($1 in a)' - ${CUSTOMTAX} | grep "$OLDEST" > ${TMP_PATH}/tmp_taxa_distances

	# Create a counter for the homology detection failure test
	COUNTER_HDF=3
	let PHYLORANK-=1

	IFS=$'\n'
	for STRATUM in $(echo ${QPHYLOS} | sed "s/,/\n/g" | tail -n +3); do

		# Extract the position and name of the outgroup phylostratum in the custom NCBI_lineages file
		COUNTER_OUTGROUP=$((${COUNTER_HDF} + 1))
		OUTGROUP_STRATUM=$(echo ${QPHYLOS} | awk -F "," -v COUNTER_OUTGROUP="$COUNTER_OUTGROUP" '{ print $COUNTER_OUTGROUP }')

		# Extract the list of outgroup species that can be used to test each of the phylostrata in the analysis
		awk -F "," -v COUNTER_HDF="$COUNTER_HDF" -v STRATUM="$STRATUM" -v COUNTER_OUTGROUP="$COUNTER_OUTGROUP" -v OUTGROUP_STRATUM="$OUTGROUP_STRATUM" '{ if ($COUNTER_HDF != STRATUM && $COUNTER_OUTGROUP == OUTGROUP_STRATUM) print $1 }' ${TMP_PATH}/tmp_taxa_distances > ${TMP_PATH}/tmp_outgroups

		# Obtain the outgroup for each phylostratum with the lowest evolutionary distance to the target species
		HDF_OUTGROUP=$(grep -w -f ${TMP_PATH}/tmp_outgroups ${DIVERGENCE} | sort -t$'\t' -nk2 | head -1 | cut -d "	" -f1)

		# Obtain the column in the bitscore file that corresponds to the outgroup of each phylostratum, so it can be used for the homology detection failure test
		OUTGROUP_COLUMN=$(head -1 ${NCBITAX}_bitscores.tsv | sed -n $'1s/\t/\\\n/gp' | grep -w -nx "$HDF_OUTGROUP" | cut -d: -f1)

		# Print all the gene founder events that passed the homology detection failure test
		awk -F "\t" -v STRATUM="$STRATUM" '{ if ($2 == STRATUM) print $1 }' ${NCBITAX}_gene_ages.tsv > ${TMP_PATH}/tmp_level_${COUNTER_HDF}_genes.txt
		grep -v "#" ${NCBITAX}_abSENSE_results/Detection_failure_probabilities | awk -F "\t" -v OUTGROUP_COLUMN="$OUTGROUP_COLUMN" '{ if ($OUTGROUP_COLUMN <= 0.05) print $1 }' | grep -w -f ${TMP_PATH}/tmp_level_${COUNTER_HDF}_genes.txt > ${TMP_PATH}/tmp_HDF_${COUNTER_HDF} && grep -f ${TMP_PATH}/tmp_HDF_${COUNTER_HDF} ${NCBITAX}_gene_ages.tsv >> ${NCBITAX}_high_confidence_gene_ages.tsv
		awk -F "\t" -v STRATUM="$STRATUM" '{ if ($2 == STRATUM) print $0 }' ${NCBITAX}_founder_events.tsv | grep -f ${TMP_PATH}/tmp_HDF_${COUNTER_HDF} >> ${NCBITAX}_high_confidence_founder_events.tsv
		rm ${TMP_PATH}/tmp_level_${COUNTER_HDF}_genes.txt ${TMP_PATH}/tmp_HDF_${COUNTER_HDF} ${TMP_PATH}/tmp_outgroups

		# Create the summary files for the gene age assignment and the gene-family founder events
		if [[ -z ${HDF_OUTGROUP} ]]; then

			echo -e "NA\t${STRATUM}\t${PHYLORANK}\tNO OUTGROUP" >> ${NCBITAX}_high_confidence_founder_summary.tsv
			echo -e "NA\t${STRATUM}\t${PHYLORANK}\tNO OUTGROUP" >> ${NCBITAX}_high_confidence_gene_age_summary.tsv

		else

			NUMGENES=$(awk -F "\t" -v STRATUM="$STRATUM" '{ if ($2 == STRATUM) print $0 }' ${NCBITAX}_high_confidence_gene_ages.tsv | wc -l)
			NUMFOUNDERS=$(awk -F "\t" -v STRATUM="$STRATUM" '{ if ($2 == STRATUM) print $0 }' ${NCBITAX}_high_confidence_founder_events.tsv | wc -l)
			echo -e "${NUMFOUNDERS}\t${STRATUM}\t${PHYLORANK}\t${HDF_OUTGROUP}" >> ${NCBITAX}_high_confidence_founder_summary.tsv
			echo -e "${NUMGENES}\t${STRATUM}\t${PHYLORANK}\t${HDF_OUTGROUP}" >> ${NCBITAX}_high_confidence_gene_age_summary.tsv

		fi

		# Modify the counters and continue with the loop
		let COUNTER_HDF+=1
		let PHYLORANK-=1

	done

	rm ${TMP_PATH}/tmp_taxa_distances
	mv ${NCBITAX}_bitscores.tsv ${NCBITAX}_abSENSE_results/

	echo "--------------------------------------------------"
	echo "Step 4 finished!"
	echo "The detection failure probabilities for each for your genes can be found in ${NCBITAX}_abSENSE_results/Detection_failure_probabilities"
	echo "A list of high-confidence gene age assignments can be found in ${NCBITAX}_high_confidence_gene_ages.tsv"
	echo "A list of high-confidence gene-family founder events can be found in ${NCBITAX}_high_confidence_founder_events.tsv"
	echo "The summary files for this analysis are found in ${NCBITAX}_high_confidence_gene_age_summary.tsv and ${NCBITAX}_high_confidence_founder_summary.tsv"
#	echo "Please refer to the following paper for an in-depth interpretation of homolohy detection failure probabilities:"
#	echo "Weisman, C.M., Murray, A.W., & Eddy, S.R. (2020). Many, but not all, lineage-specific genes can be explained by homology detection failure. PLoS biology, 18(11), e3000862."

fi

echo
echo "genEra finished at:"
date
echo
echo "Enjoy your results!!!"
